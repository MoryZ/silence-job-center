# SilenceJob 项目开发规范

## 1. 项目架构

### 1.1 模块划分

```
silence-job-center/
├── silence-job-common/          # 公共模块
│   ├── silence-job-common-core/       # 核心工具类
│   ├── silence-job-common-log/        # 日志组件
│   ├── silence-job-common-client-api/ # 客户端 API
│   └── silence-job-common-server-api/ # 服务端 API
├── silence-job-client/          # 客户端模块
│   ├── silence-job-client-common/     # 客户端公共组件
│   ├── silence-job-client-core/       # 客户端核心
│   └── silence-job-client-retry-core/ # 重试核心
├── silence-job-server/          # 服务端模块
│   ├── silence-job-server-app/        # 应用层（API、Service）
│   ├── silence-job-server-core/       # 核心领域模型
│   ├── silence-job-server-common/     # 服务端公共组件
│   └── silence-job-server-job-task/   # 任务执行引擎
└── silence-job-client-starter/  # 客户端 Starter
└── silence-job-server-starter/  # 服务端 Starter
```

### 1.2 分层架构

采用 DDD（领域驱动设计）分层架构：

- **API 层** (`*Resource.java`): REST 接口定义，负责参数校验和响应转换
- **Application 层** (`*Service.java`): 业务编排，事务控制
- **Domain 层** (`domain/model/*.java`): 领域模型和核心业务逻辑
- **Infrastructure 层** (`infrastructure/persistence/dao/*.java`): 数据访问

**关键原则：**
- Controller 只做参数校验和结果封装，不包含业务逻辑
- Service 负责业务编排和事务管理
- 复杂查询逻辑封装在 `Access` 接口中（如 `GroupConfigAccess`）
- DAO 层使用 MyBatis-Plus 的 `BaseMapper`

**示例：**

参考 `JobResource` -> `JobService` 的调用链。

---

## 2. 数据库规范

### 2.1 表命名规范

- **前缀统一**: 所有表以 `sj_` 开头（silence-job 缩写）
- **示例**: 
  - `sj_job` - 任务表
  - `sj_workflow` - 工作流表
  - `sj_retry_task` - 重试任务表
  - `sj_group_config` - 组配置表

### 2.2 实体类规范

所有实体类继承 `AbstractAutoGeneratedIdAuditableTenantable<BigInteger, String>`，包含以下字段：

**必需字段：**
- `id` - 主键（BigInteger 类型）
- `createdAt` - 创建时间（Instant 类型）
- `updatedAt` - 更新时间（Instant 类型）
- `createdBy` - 创建人（String）
- `updatedBy` - 更新人（String）
- `tenantId` - 租户 ID（String，用于多租户隔离）

**逻辑删除：**
- 使用 `@TableLogic` 注解标记 `deleted` 字段（Boolean 类型）
- 参考 `Job.java` 和 `Workflow.java`

**乐观锁：**
- 版本号字段使用 `@TableField(value = "version", update = "%s+1")`
- 示例：`GroupConfig.version`

### 2.3 JSON 字段处理

**存储 JSON 字符串的字段命名建议：**
- `flowInfo` - 流程信息
- `extAttrs` - 扩展属性
- `notifyIds` - 通知配置 ID 列表（逗号分隔或 JSON 数组）

**序列化/反序列化：**
- 使用 `JsonUtils` 工具类
- 支持的方法：
  - `toJsonString(Object)` - 对象转 JSON
  - `parseObject(String, Class<T>)` - JSON 转对象
  - `parseList(String, Class<T>)` - JSON 数组转 List
  - `isValidJson(String)` - 校验 JSON 合法性

**示例：**
```java
// 序列化
String flowInfo = JsonUtils.toJsonString(nodeConfig);

// 反序列化
NodeConfig config = JsonUtils.parseObject(flowInfo, NodeConfig.class);

// 校验
if (!JsonUtils.isValidJson(jsonString)) {
    throw new SilenceJobServerException("非法的 JSON 格式");
}
```

---

## 3. 常用工具栈

### 3.1 核心依赖

| 技术栈 | 用途 | 关键类/示例 |
|--------|------|-------------|
| **MyBatis-Plus** | ORM 框架 | `BaseMapper`, `LambdaQueryWrapper` |
| **Hutool** | 工具库 | `StrUtil`, `CollUtil`, `Assert` |
| **Fastjson2** | JSON 处理 | `JsonUtils` |
| **Pekko (Actor)** | 异步任务调度 | `AbstractClientCallbackHandler` |
| **Spring Validation** | 参数校验 | `@NotNull`, `@NotBlank`, `@Pattern` |
| **MapStruct** | 对象映射 | `WorkflowMapper` |
| **Guava** | 图结构、缓存 | `MutableGraph`, `CacheBuilder` |

### 3.2 自定义工具类

**集合操作：**
- `StreamUtils` - Stream 流增强
- `CollectionUtils` - 集合工具

**JSON 工具：**
- `JsonUtils` - 统一的 JSON 序列化工具

**环境工具：**
- `EnvironmentUtils` - 获取环境变量和配置

**通知工具：**
- `DingDingUtils` - 钉钉告警

### 3.3 表达式引擎

支持多种表达式类型：

- **SpEL** (Spring Expression Language)
- **Aviator** 
- **QL** (自定义查询语言)

使用 `ExpressionFactory` 获取对应引擎。

---

## 4. 开发红线

### 4.1 禁止事项

#### ❌ 禁止在循环中查询数据库
```java
// ❌ 错误示例
for (BigInteger id : ids) {
    Job job = jobDao.selectById(id);
    // ...
}

// ✅ 正确示例
List<Job> jobs = jobDao.selectBatchIds(ids);
```

#### ❌ 禁止吞掉异常堆栈
```java
// ❌ 错误示例
try {
    // ...
} catch (Exception e) {
    log.error("处理失败");
}

// ✅ 正确示例
try {
    // ...
} catch (Exception e) {
    log.error("处理失败", e);
    throw new SilenceJobServerException("处理失败", e);
}
```

#### ❌ 禁止直接修改集合类参数
参考 `GroupVersionCache`，避免并发问题。

#### ❌ 禁止在事务方法中捕获异常不抛出
```java
@Transactional
public void doSomething() {
    try {
        // ...
    } catch (Exception e) {
        // ❌ 事务不会回滚！
        log.error("error", e);
        return;
    }
}
```

### 4.2 必需遵循

#### ✅ 使用 Assert 进行前置校验
参考 `GroupConfigService`：

```java
Assert.isTrue(count > 0, 
    () -> new SilenceJobServerException("组:[{}]已经关闭", groupName));
```

#### ✅ 使用 Optional 处理可空值
```java
groupConfig.setDescription(
    Optional.ofNullable(groupConfig.getDescription()).orElse(StrUtil.EMPTY)
);
```

#### ✅ 枚举类型必须定义在 `com.old.silence.job.common.enums` 包

#### ✅ DTO 命名规范
- **Command** - 写操作请求（如 `WorkflowCommand`）
- **Query** - 查询请求（如 `WorkflowQuery`）
- **ResponseVO** - 响应对象（如 `WorkflowResponseVO`）

#### ✅ 分页查询使用 MyBatis-Plus 的 Page
```java
public IPage<WorkflowResponseVO> queryPage(Page<Workflow> page, WorkflowQuery query) {
    Page<Workflow> result = workflowDao.selectPage(page,
        new LambdaQueryWrapper<Workflow>()
            .eq(Workflow::getDeleted, false)
            .like(StrUtil.isNotBlank(query.getWorkflowName()), 
                  Workflow::getWorkflowName, query.getWorkflowName())
    );
    return result.convert(workflowMapper::convert);
}
```

#### ✅ 日志规范
- 使用 `SilenceJobLog` 统一日志门面
- 敏感信息脱敏后打印
- 关键业务节点必须打印日志

---

## 5. 常用代码模板

### 5.1 新增实体类
```java
@TableName("sj_xxx")
public class XxxEntity extends AbstractAutoGeneratedIdAuditableTenantable<BigInteger, String> {
    private String name;
    
    @TableLogic
    @TableField(value = "is_deleted")
    private Boolean deleted;
    
    @TableField(value = "version", update = "%s+1")
    private Integer version;
}
```

### 5.2 新增 Service 方法
```java
@Transactional
public Boolean create(XxxCommand command) {
    // 1. 参数校验
    Assert.notBlank(command.getName(), "名称不能为空");
    
    // 2. 业务校验
    long count = xxxDao.selectCount(
        new LambdaQueryWrapper<Xxx>()
            .eq(Xxx::getName, command.getName())
    );
    Assert.isTrue(count == 0, 
        () -> new SilenceJobServerException("名称已存在"));
    
    // 3. 执行业务逻辑
    Xxx entity = xxxMapper.convert(command);
    Assert.isTrue(1 == xxxDao.insert(entity),
        () -> new SilenceJobServerException("新增失败"));
    
    return Boolean.TRUE;
}
```

### 5.3 新增 REST 接口
```java
@RestController
@RequestMapping("/api/v1")
public class XxxResource {
    
    @PostMapping("/xxx")
    public Boolean create(@Validated @RequestBody XxxCommand command) {
        return xxxService.create(command);
    }
    
    @GetMapping("/xxx/{id}")
    public XxxResponseVO getById(@PathVariable BigInteger id) {
        return xxxService.getById(id);
    }
}
```

---

## 6. 配置规范

### 6.1 常量定义
所有常量定义在 `SystemConstants`：

```java
public interface SystemConstants {
    String DEFAULT_NAMESPACE = "764d604ec6fc45f68cd92514c40e9e1a";
    String DEFAULT_TOKEN = "SJ_Wyz3dmsdbDOkDujOTSSoBjGQP1BMsVnj";
    Long SCHEDULE_PERIOD = 10L;
}
```

### 6.2 多租户支持
- 所有实体类必须包含 `tenantId` 字段
- 查询时自动注入租户条件（通过 `TenantInterceptor`）

---

## 7. 测试规范

### 7.1 单元测试
- Service 层必须编写单元测试
- 使用 Mockito 模拟依赖
- 测试覆盖率不低于 70%

### 7.2 集成测试
- 使用 `@SpringBootTest` 启动完整上下文
- 数据库使用 H2 内存数据库

---

## 8. 版本管理

### 8.1 提交规范
遵循 [Conventional Commits](https://www.conventionalcommits.org/)：

```
feat: 新增工作流决策节点功能
fix: 修复任务重试次数统计错误
docs: 更新 API 文档
refactor: 重构任务调度逻辑
```

### 8.2 分支管理
- `main` - 主分支（生产环境）
- `develop` - 开发分支
- `feature/*` - 功能分支
- `hotfix/*` - 紧急修复分支

---

## 附录：快速参考

### 数据库字段约定
| 字段名 | 类型 | 备注 |
|--------|------|------|
| id | BigInteger | 主键，自增 |
| created_at | DATETIME | 创建时间，自动填充 |
| updated_at | DATETIME | 更新时间，自动填充 |
| created_by | VARCHAR(50) | 创建人 |
| updated_by | VARCHAR(50) | 更新人 |
| tenant_id | VARCHAR(50) | 租户ID，用于多租户隔离 |
| deleted | BOOLEAN | 逻辑删除标记，默认0 |
| version | INT | 乐观锁版本号，默认0 |

### 常用注解
- `@Transactional` - 事务控制（Service 层）
- `@Validated` - 参数校验（Controller 层）
- `@TableLogic` - 逻辑删除标记
- `@TableName("sj_xxx")` - 表名映射
- `@TableField(value = "xxx", update = "%s+1")` - 版本号自增

### 异常处理规范
```java
// ✅ 正确做法
throw new SilenceJobServerException("业务异常信息");
throw new SilenceJobServerException("异常信息：{}", e.getMessage(), e);

// ❌ 禁止做法
throw new RuntimeException("错误");  // 使用特定异常类
e.printStackTrace();                   // 禁止直接打印堆栈
log.error("error");                   // 必须记录完整的异常堆栈
```

---

## 附录 B：Maven 依赖管理规范

### 当前依赖问题诊断

#### ❌ 发现的问题

1. **版本号管理混乱**
   - `jackson-annotations` 硬编码为 `2.13.5`，应使用 Spring Boot 管理的版本
   - `fastjson2-extension` 硬编码为 `2.0.52`，应在根 pom 统一管理
   - `mysql-connector-j` 使用了未定义的 `${mysql-connector-j.version}` 属性
   - `mapstruct` 使用了未定义的 `${mapstruct.version}` 属性

2. **dependencyManagement 不完整**
   - `silence-job-server/pom.xml` 中的 dependencyManagement 缺少 `<version>` 标签
   - 多个子模块依赖未在父 pom 中统一管理版本

3. **依赖传递污染**
   - 多个模块重复声明同样的依赖
   - 缺少合理的 `<exclusions>` 排除冲突依赖

4. **scope 使用不当**
   - 表达式引擎（Aviator、QLExpress）在 common-core 中是 `provided`，但应在根 pom 统一管理

### 优化建议

#### ✅ 根 pom.xml 补充版本属性

在 `<properties>` 中补充缺失的版本定义：

```xml
<properties>
    <!-- 现有属性保持不变 -->
    
    <!-- 补充缺失的版本 -->
    <fastjson2.version>2.0.52</fastjson2.version>
    <jackson.version>2.17.0</jackson.version>
    <mapstruct.version>1.5.5.Final</mapstruct.version>
    <mysql-connector-j.version>8.4.0</mysql-connector-j.version>
    
    <!-- Spring Boot BOM 已管理，无需重复定义 -->
    <!-- jackson-core, jackson-databind, spring-* 等 -->
</properties>
```

#### ✅ 完善 dependencyManagement

在根 pom 的 `<dependencyManagement>` 中补充：

```xml
<dependencyManagement>
    <dependencies>
        <!-- 现有依赖保持不变 -->
        
        <!-- 补充缺失的版本管理 -->
        <dependency>
            <groupId>com.alibaba.fastjson2</groupId>
            <artifactId>fastjson2</artifactId>
            <version>${fastjson2.version}</version>
        </dependency>
        
        <dependency>
            <groupId>com.alibaba.fastjson2</groupId>
            <artifactId>fastjson2-extension</artifactId>
            <version>${fastjson2.version}</version>
        </dependency>
        
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <version>${mysql-connector-j.version}</version>
        </dependency>
        
        <!-- Jackson 依赖使用 Spring Boot 管理的版本，不要单独指定 -->
        
    </dependencies>
</dependencyManagement>
```

#### ✅ 修复 silence-job-server/pom.xml

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.old.silence</groupId>
            <artifactId>silence-job-server-common</artifactId>
            <version>1.8.0-SNAPSHOT</version> <!-- 补充 version -->
        </dependency>

        <dependency>
            <groupId>com.old.silence</groupId>
            <artifactId>silence-job-server-retry-task</artifactId>
            <version>1.8.0-SNAPSHOT</version> <!-- 补充 version -->
        </dependency>
        
        <dependency>
            <groupId>com.old.silence</groupId>
            <artifactId>silence-job-server-job-task</artifactId>
            <version>1.8.0-SNAPSHOT</version> <!-- 补充 version -->
        </dependency>
    </dependencies>
</dependencyManagement>
```

#### ✅ 移除硬编码版本号

**silence-job-common-core/pom.xml** 修改：

```xml
<!-- ❌ 错误 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.13.5</version> <!-- 硬编码版本 -->
</dependency>

<!-- ✅ 正确 - 使用 Spring Boot 管理的版本 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <!-- 不指定 version，继承 Spring Boot BOM -->
</dependency>
```

```xml
<!-- ❌ 错误 -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2-extension</artifactId>
    <version>2.0.52</version> <!-- 硬编码版本 -->
</dependency>

<!-- ✅ 正确 - 使用父 pom 管理的版本 -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2-extension</artifactId>
    <!-- 不指定 version，继承父 pom dependencyManagement -->
</dependency>
```

### 依赖管理最佳实践

#### 1. 版本统一原则

```xml
<!-- 根 pom.xml -->
<properties>
    <my-library.version>1.2.3</my-library.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>my-library</artifactId>
            <version>${my-library.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 子模块 pom.xml -->
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>my-library</artifactId>
        <!-- 不指定 version -->
    </dependency>
</dependencies>
```

#### 2. BOM 导入优先

```xml
<dependencyManagement>
    <dependencies>
        <!-- Spring Boot BOM 已包含大量常用依赖版本 -->
        <!-- 通过 parent 继承时自动引入 -->
        
        <!-- Hutool BOM -->
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-bom</artifactId>
            <version>${hutool.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

#### 3. 模块版本统一使用 ${project.version}

```xml
<!-- ❌ 错误 - 硬编码项目版本 -->
<dependency>
    <groupId>com.old.silence</groupId>
    <artifactId>silence-job-common-core</artifactId>
    <version>1.8.0-SNAPSHOT</version>
</dependency>

<!-- ✅ 正确 - 使用占位符 -->
<dependency>
    <groupId>com.old.silence</groupId>
    <artifactId>silence-job-common-core</artifactId>
    <version>${project.version}</version>
</dependency>

<!-- 或在根 pom 的 dependencyManagement 中统一管理 -->
```

#### 4. 合理使用 scope 和 optional

```xml
<!-- provided: 编译时需要，运行时由容器提供 -->
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <scope>provided</scope>
</dependency>

<!-- optional: 可选依赖，不传递给下游 -->
<dependency>
    <groupId>com.googlecode.aviator</groupId>
    <artifactId>aviator</artifactId>
    <optional>true</optional>
</dependency>

<!-- test: 仅测试时使用 -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>
```

#### 5. 及时排除冲突依赖

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>QLExpress</artifactId>
    <exclusions>
        <exclusion>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

### 依赖检查命令

```bash
# 查看依赖树
mvn dependency:tree

# 查看依赖冲突
mvn dependency:tree -Dverbose

# 分析依赖
mvn dependency:analyze

# 查看有效 POM（包含继承和 BOM 导入后的完整依赖）
mvn help:effective-pom
```

### 推荐的根 pom 结构

```xml
<properties>
    <!-- 1. 项目基本配置 -->
    <maven.compiler.source>21</maven.compiler.source>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    
    <!-- 2. 核心框架版本（如果不使用 Spring Boot Parent） -->
    <!-- <spring-boot.version>3.2.0</spring-boot.version> -->
    
    <!-- 3. 第三方库版本（按字母排序） -->
    <aviator.version>5.3.3</aviator.version>
    <fastjson2.version>2.0.52</fastjson2.version>
    <guava.version>33.3.0-jre</guava.version>
    <hutool.version>5.8.32</hutool.version>
    <mapstruct.version>1.5.5.Final</mapstruct.version>
    <!-- ... -->
    
    <!-- 4. 插件版本 -->
    <maven-compiler-plugin.version>3.11.0</maven-compiler-plugin.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!-- 1. BOM 导入（最先） -->
        <dependency>
            <groupId>cn.hutool</groupId>
            <artifactId>hutool-bom</artifactId>
            <version>${hutool.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <!-- 2. 内部模块依赖 -->
        <dependency>
            <groupId>com.old.silence</groupId>
            <artifactId>silence-job-common-core</artifactId>
            <version>${project.version}</version>
        </dependency>
        
        <!-- 3. 第三方依赖（按分类分组） -->
        <!-- Utils -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>${guava.version}</version>
        </dependency>
        
        <!-- JSON -->
        <dependency>
            <groupId>com.alibaba.fastjson2</groupId>
            <artifactId>fastjson2</artifactId>
            <version>${fastjson2.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

---

## 附录 C：namespaceId 使用规范

### 问题分析

`namespaceId` 在项目中的使用存在以下混乱：

1. **语义不清晰** - 有时表示全局命名空间（DEFAULT_NAMESPACE），有时表示具体的租户隔离空间
2. **获取方式不一致** - 有时从 HTTP 请求头获取，有时从 Job 对象中获取
3. **应用场景差异大** - 一些操作需要指定 namespaceId，一些不需要

### namespaceId 的两种使用模式

#### 模式 1：全局默认命名空间（Global Namespace）

**定义**：系统默认的全局命名空间，所有微服务共享
```java
String DEFAULT_NAMESPACE = "764d604ec6fc45f68cd92514c40e9e1a";
```

**使用场景**：
- 客户端和服务端通信建立连接时
- 注册中心（CacheRegisterTable）的服务发现
- 跨租户的全局系统操作

**典型代码**：
```java
// 服务端发送请求给客户端，使用全局命名空间
headersMap.put(HeadersEnum.NAMESPACE.getKey(), SystemConstants.DEFAULT_NAMESPACE);

// 查询客户端集群信息，使用全局命名空间
Set<RegisterNodeInfo> nodes = CacheRegisterTable.getServerNodeSet(
    context.getGroupName(), 
    context.getNamespaceId()  // 此时应使用 DEFAULT_NAMESPACE
);
```

#### 模式 2：租户隔离命名空间（Tenant Namespace）

**定义**：与 Job/Workflow 关联的租户隔离标识，用于数据隔离查询
```java
// 从 HTTP 请求头中获取，由客户端指定
String namespaceId = HttpHeaderUtil.getNamespace(headers);

// 或从 Job 对象中获取
String namespaceId = job.getNamespaceId();
```

**使用场景**：
- 数据库查询条件（WHERE namespaceId = ?）
- API 请求头中标识租户身份
- 跨租户的数据隔离验证

**典型代码**：
```java
// 删除任务时，按租户和任务ID过滤
String namespaceId = HttpHeaderUtil.getNamespace(headers);
jobDao.delete(
    new LambdaQueryWrapper<Job>()
        .eq(Job::getNamespaceId, namespaceId)  // 租户隔离
        .in(Job::getId, ids)
);

// 查询任务配置信息，按租户隔离
GroupConfig groupConfig = groupConfigDao.selectOne(
    new LambdaQueryWrapper<GroupConfig>()
        .eq(GroupConfig::getNamespaceId, job.getNamespaceId())  // 使用 job 的租户
        .eq(GroupConfig::getGroupName, job.getGroupName())
);
```

### 使用规范

#### ✅ 正确的使用方式

**Rule 1：RPC 通信使用 DEFAULT_NAMESPACE**

```java
// ✅ 正确 - 客户端集群查询使用全局命名空间
Set<RegisterNodeInfo> nodes = CacheRegisterTable.getServerNodeSet(
    context.getGroupName(), 
    SystemConstants.DEFAULT_NAMESPACE  // 显式指定全局命名空间
);

// ✅ 正确 - 服务端向客户端发送请求
headersMap.put(
    HeadersEnum.NAMESPACE.getKey(), 
    SystemConstants.DEFAULT_NAMESPACE
);
```

**Rule 2：数据库查询使用租户 namespaceId**

```java
// ✅ 正确 - 按租户查询任务
String tenantNamespaceId = HttpHeaderUtil.getNamespace(headers);  // 从请求头获取
jobDao.delete(
    new LambdaQueryWrapper<Job>()
        .eq(Job::getNamespaceId, tenantNamespaceId)  // 用租户 ID 隔离数据
        .in(Job::getId, ids)
);

// ✅ 正确 - 使用 Job 对象的租户信息
GroupConfig config = groupConfigDao.selectOne(
    new LambdaQueryWrapper<GroupConfig>()
        .eq(GroupConfig::getNamespaceId, job.getNamespaceId())
        .eq(GroupConfig::getGroupName, job.getGroupName())
);
```

**Rule 3：Context 对象中的 namespaceId 含义需要明确注释**

```java
public class ClientCallbackContext {
    // namespaceId 在此上下文中表示：租户标识，用于数据隔离
    // 来源：从 HTTP 请求头 (HeadersEnum.NAMESPACE) 中提取
    // 与 DEFAULT_NAMESPACE 的区别：
    //   - DEFAULT_NAMESPACE: 全局通信命名空间
    //   - 此 namespaceId: 租户隔离标识
    private String namespaceId;
}

public class JobTaskGenerateContext {
    // namespaceId 在此上下文中表示：全局命名空间
    // 来源：系统常量 DEFAULT_NAMESPACE
    // 用途：用于注册中心查询客户端集群
    private String namespaceId;
}
```

#### ❌ 常见错误

**错误 1：混淆两种 namespaceId**
```java
// ❌ 错误 - 直接从 context 获取的全局 namespaceId 用于数据库查询
List<Job> jobs = jobDao.selectList(
    new LambdaQueryWrapper<Job>()
        .eq(Job::getNamespaceId, context.getNamespaceId())  // 可能是全局的！
);
```

**错误 2：从不同来源混合使用**
```java
// ❌ 错误 - 既从 Job 获取，又从请求头获取，容易混乱
String jobNamespaceId = job.getNamespaceId();
String headerNamespaceId = HttpHeaderUtil.getNamespace(headers);
if (!jobNamespaceId.equals(headerNamespaceId)) {
    // 这里的判断逻辑可能不清晰
}
```

**错误 3：缺少文档和注释**
```java
// ❌ 错误 - 无法看出这个 namespaceId 是哪种类型
public void processJob(String namespaceId, Job job) {
    Set<RegisterNodeInfo> nodes = CacheRegisterTable.getServerNodeSet(
        job.getGroupName(), 
        namespaceId  // 这里传入的是全局还是租户？
    );
}
```

### 重构建议

#### 第一步：为 Context 类添加清晰的 JavaDoc

```java
/**
 * 全局任务执行上下文
 * 
 * namespaceId 的含义：全局命名空间，用于 RPC 通信和客户端服务发现
 * 来源：系统常量 {@link SystemConstants#DEFAULT_NAMESPACE}
 * 与租户隔离的区别：此值是全局固定的，不随租户变化
 */
public class JobTaskGenerateContext {
    /**
     * 全局命名空间 ID
     * 用途：
     * - 注册中心查询：用于查询特定客户端集群的所有节点
     * - RPC 通信：作为 HTTP 请求头的命名空间标识
     * 
     * @see SystemConstants#DEFAULT_NAMESPACE
     */
    private String namespaceId;
}

/**
 * 客户端回调上下文
 * 
 * namespaceId 的含义：租户隔离标识，用于数据库查询和租户隔离
 * 来源：HTTP 请求头 {@link HeadersEnum#NAMESPACE}
 * 与全局命名空间的区别：此值来自客户端请求，表示具体的租户
 */
public class ClientCallbackContext {
    /**
     * 租户命名空间 ID
     * 用途：
     * - 数据库查询：过滤条件，确保数据隔离
     * - 任务处理：记录任务所属租户
     * 
     * @see HeadersEnum#NAMESPACE
     */
    private String namespaceId;
}
```

#### 第二步：创建语义明确的常量或方法

```java
public interface SystemConstants {
    // 明确命名：这是全局通信命名空间
    String GLOBAL_COMMUNICATION_NAMESPACE = "764d604ec6fc45f68cd92514c40e9e1a";
    
    // 保留向后兼容性
    @Deprecated(since = "1.0", forRemoval = false)
    String DEFAULT_NAMESPACE = GLOBAL_COMMUNICATION_NAMESPACE;
}

// 或者使用方法来区分语义
public class NamespaceUtil {
    /**
     * 获取全局通信命名空间，用于 RPC 和客户端发现
     */
    public static String getGlobalNamespace() {
        return SystemConstants.GLOBAL_COMMUNICATION_NAMESPACE;
    }
    
    /**
     * 获取租户隔离命名空间，用于数据查询隔离
     */
    public static String getTenantNamespace(HttpHeaders headers) {
        return headers.getAsString(HeadersEnum.NAMESPACE.getKey());
    }
}
```

#### 第三步：统一查询方法的参数命名

```java
// ❌ 旧方式 - 参数名不清晰
public Set<RegisterNodeInfo> getServerNodeSet(String groupName, String namespaceId) {
    // ???
}

// ✅ 新方式 - 参数名表达意图
public Set<RegisterNodeInfo> getServerNodeSetByGlobalNamespace(String groupName) {
    return getServerNodeSet(groupName, SystemConstants.DEFAULT_NAMESPACE);
}

public Set<RegisterNodeInfo> getServerNodeSet(String groupName, String globalNamespace) {
    // 显式的参数类型标注
}
```

### 验证清单

在使用 `namespaceId` 时，检查以下问题：

- [ ] 我清楚这个 `namespaceId` 是全局还是租户隔离的吗？
- [ ] 我是否有注释说明这个 `namespaceId` 的来源（DEFAULT_NAMESPACE 还是请求头）？
- [ ] 这个变量用在 RPC 通信中吗？应该使用 DEFAULT_NAMESPACE
- [ ] 这个变量用在数据库查询中吗？应该使用请求头中的租户 namespaceId
- [ ] 我是否混淆了两种 namespaceId 的使用场景？

---

**文档版本**: v1.0  
**最后更新**: 2026-02-03  
**维护者**: SilenceJob Team
